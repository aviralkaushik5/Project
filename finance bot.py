{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4e4775d3-adc8-486a-ad93-9e1a8799c81e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Downloaded nifty50.csv\n",
      "Downloaded nifty500.csv\n",
      "Bot starting...\n"
     ]
    }
   ],
   "source": [
    "# telegram_finance_bot.py\n",
    "# -------------------------------------------------------------\n",
    "# ONE FILE: Stocks search + charts + AI-ish insights + Investment planner with pie chart\n",
    "# + Company actions: Balance Sheet, Ratios, Peer Comparison, Pros & Cons\n",
    "# -------------------------------------------------------------\n",
    "\n",
    "import os\n",
    "import math\n",
    "import requests\n",
    "import telebot\n",
    "from telebot import types\n",
    "import pandas as pd\n",
    "import yfinance as yf\n",
    "import matplotlib.pyplot as plt\n",
    "from io import BytesIO\n",
    "from datetime import datetime\n",
    "import difflib\n",
    "import re\n",
    "\n",
    "# ---------------- CONFIG ----------------\n",
    "TOKEN = os.getenv(\"BOT_TOKEN\", \"7957451812:AAG1_yo8Jwmc2m01uuEjwxhuUsAty_pskpU\")  # Prefer env var\n",
    "bot = telebot.TeleBot(TOKEN, parse_mode=None)  # set parse_mode per-message\n",
    "\n",
    "NIFTY50_URL = \"https://archives.nseindia.com/content/indices/ind_nifty50list.csv\"\n",
    "NIFTY500_URL = \"https://archives.nseindia.com/content/indices/ind_nifty500list.csv\"\n",
    "NIFTY50_FILE = \"nifty50.csv\"\n",
    "NIFTY500_FILE = \"nifty500.csv\"\n",
    "\n",
    "# chat_state: per-chat, we track modes and stages\n",
    "chat_state = {}\n",
    "\n",
    "# ---------------- NAME ‚Üí TICKER MAP (popular) ----------------\n",
    "NAME_TICKER = {\n",
    "    # US mega caps\n",
    "    \"apple\": \"AAPL\", \"tesla\": \"TSLA\", \"microsoft\": \"MSFT\", \"google\": \"GOOGL\",\n",
    "    \"alphabet\": \"GOOGL\", \"amazon\": \"AMZN\", \"meta\": \"META\", \"facebook\": \"META\",\n",
    "    \"nvidia\": \"NVDA\", \"netflix\": \"NFLX\", \"amd\": \"AMD\", \"intel\": \"INTC\",\n",
    "    \"micron\": \"MU\", \"broadcom\": \"AVGO\", \"salesforce\": \"CRM\", \"adobe\": \"ADBE\",\n",
    "    \"paypal\": \"PYPL\", \"visa\": \"V\", \"mastercard\": \"MA\", \"coca cola\": \"KO\",\n",
    "    \"cocacola\": \"KO\", \"pepsi\": \"PEP\", \"jpmorgan\": \"JPM\", \"berkshire\": \"BRK-B\",\n",
    "    \"boeing\": \"BA\", \"disney\": \"DIS\", \"uber\": \"UBER\",\n",
    "    # India large caps (NSE suffix)\n",
    "    \"reliance\": \"RELIANCE.NS\", \"tcs\": \"TCS.NS\", \"infosys\": \"INFY.NS\",\n",
    "    \"hdfc bank\": \"HDFCBANK.NS\", \"icici bank\": \"ICICIBANK.NS\", \"itc\": \"ITC.NS\",\n",
    "    \"sbi\": \"SBIN.NS\", \"larsen & toubro\": \"LT.NS\", \"lnt\": \"LT.NS\",\n",
    "    \"bharti airtel\": \"BHARTIARTL.NS\", \"hcl\": \"HCLTECH.NS\", \"ongc\": \"ONGC.NS\",\n",
    "    \"axis bank\": \"AXISBANK.NS\", \"kotak bank\": \"KOTAKBANK.NS\", \"maruti\": \"MARUTI.NS\",\n",
    "    \"titan\": \"TITAN.NS\", \"ultratech\": \"ULTRACEMCO.NS\", \"jsw steel\": \"JSWSTEEL.NS\",\n",
    "    \"hindustan unilever\": \"HINDUNILVR.NS\",\n",
    "    # Other exchanges (handful for convenience)\n",
    "    \"taiwan semiconductor\": \"TSM\", \"asml\": \"ASML\",\n",
    "    \"sap\": \"SAP\", \"siemens\": \"SIE.DE\", \"lvmh\": \"MC.PA\", \"hsbc\": \"0005.HK\",\n",
    "    \"shopify\": \"SHOP.TO\", \"rio tinto\": \"RIO.L\", \"sony\": \"6758.T\",\n",
    "    \"dbs\": \"D05.SI\", \"nestle\": \"NESN.SW\", \"toyota\": \"7203.T\",\n",
    "}\n",
    "\n",
    "# Predefined universes used to fetch peers quickly (keeps it fast & reliable)\n",
    "INDIA_LARGE_UNIVERSE = [\n",
    "    \"RELIANCE.NS\",\"TCS.NS\",\"INFY.NS\",\"HDFCBANK.NS\",\"ICICIBANK.NS\",\"ITC.NS\",\"SBIN.NS\",\n",
    "    \"LT.NS\",\"BHARTIARTL.NS\",\"HCLTECH.NS\",\"AXISBANK.NS\",\"KOTAKBANK.NS\",\"MARUTI.NS\",\n",
    "    \"ULTRACEMCO.NS\",\"JSWSTEEL.NS\",\"HINDUNILVR.NS\",\"TITAN.NS\"\n",
    "]\n",
    "US_LARGE_UNIVERSE = [\n",
    "    \"AAPL\",\"MSFT\",\"GOOGL\",\"AMZN\",\"META\",\"NVDA\",\"TSLA\",\"JPM\",\"V\",\"MA\",\"KO\",\"PEP\",\"INTC\",\n",
    "    \"AMD\",\"ADBE\",\"CRM\",\"NFLX\",\"AVGO\",\"BA\",\"DIS\",\"PYPL\",\"UBER\"\n",
    "]\n",
    "\n",
    "# ---------------- UTILITIES ----------------\n",
    "def try_download(url, filename):\n",
    "    headers = {\"User-Agent\": \"Mozilla/5.0\"}\n",
    "    try:\n",
    "        r = requests.get(url, headers=headers, timeout=10)\n",
    "        r.raise_for_status()\n",
    "        with open(filename, \"wb\") as f:\n",
    "            f.write(r.content)\n",
    "        print(f\"Downloaded {filename}\")\n",
    "        return True\n",
    "    except Exception as e:\n",
    "        print(f\"Download failed for {url}: {e}\")\n",
    "        return False\n",
    "\n",
    "def load_index_csv(local_filename):\n",
    "    if not os.path.exists(local_filename):\n",
    "        return pd.DataFrame(columns=[\"SYMBOL\", \"NAME\"])\n",
    "    try:\n",
    "        df = pd.read_csv(local_filename)\n",
    "        symbol_col = None\n",
    "        name_col = None\n",
    "        for c in df.columns:\n",
    "            low = c.lower()\n",
    "            if \"symbol\" in low and symbol_col is None:\n",
    "                symbol_col = c\n",
    "            if (\"company\" in low or \"name\" in low) and name_col is None:\n",
    "                name_col = c\n",
    "        if symbol_col is None:\n",
    "            symbol_col = df.columns[0]\n",
    "        if name_col is None:\n",
    "            name_col = df.columns[1] if len(df.columns) > 1 else df.columns[0]\n",
    "        df2 = df[[symbol_col, name_col]].copy()\n",
    "        df2.columns = [\"SYMBOL\",\"NAME\"]\n",
    "        df2[\"SYMBOL\"] = df2[\"SYMBOL\"].astype(str).str.strip().str.upper()\n",
    "        df2[\"NAME\"] = df2[\"NAME\"].astype(str).str.strip().str.lower()\n",
    "        return df2\n",
    "    except Exception as e:\n",
    "        print(\"Error parsing CSV:\", e)\n",
    "        return pd.DataFrame(columns=[\"SYMBOL\", \"NAME\"])\n",
    "\n",
    "def compute_rsi(series, period=14):\n",
    "    delta = series.diff().dropna()\n",
    "    up = delta.clip(lower=0)\n",
    "    down = -delta.clip(upper=0)\n",
    "    ema_up = up.ewm(com=(period-1), adjust=False).mean()\n",
    "    ema_down = down.ewm(com=(period-1), adjust=False).mean()\n",
    "    rs = ema_up / (ema_down.replace(0, 1e-10))\n",
    "    rsi = 100 - (100 / (1 + rs))\n",
    "    return rsi\n",
    "\n",
    "def human_volume(v):\n",
    "    try:\n",
    "        v = int(v)\n",
    "        if v >= 10**12:  # trillion\n",
    "            return f\"{v/10**12:.2f}T\"\n",
    "        if v >= 10**9:\n",
    "            return f\"{v/10**9:.2f}B\"\n",
    "        if v >= 10**7:\n",
    "            return f\"{v/10**7:.2f}Cr\"\n",
    "        if v >= 10**5:\n",
    "            return f\"{v/10**5:.2f}L\"\n",
    "        if v >= 1000:\n",
    "            return f\"{v/1000:.2f}K\"\n",
    "        return str(v)\n",
    "    except:\n",
    "        return str(v)\n",
    "\n",
    "def human_number(n):\n",
    "    try:\n",
    "        n = float(n)\n",
    "        absn = abs(n)\n",
    "        if absn >= 1e12: return f\"{n/1e12:.2f}T\"\n",
    "        if absn >= 1e9:  return f\"{n/1e9:.2f}B\"\n",
    "        if absn >= 1e7:  return f\"{n/1e7:.2f}Cr\"\n",
    "        if absn >= 1e5:  return f\"{n/1e5:.2f}L\"\n",
    "        if absn >= 1e3:  return f\"{n/1e3:.2f}K\"\n",
    "        return f\"{n:.0f}\"\n",
    "    except:\n",
    "        return str(n)\n",
    "\n",
    "def pct(n):\n",
    "    try:\n",
    "        return f\"{float(n)*100:.1f}%\"\n",
    "    except:\n",
    "        return \"‚Äî\"\n",
    "\n",
    "def create_chart_bytes(df, title):\n",
    "    fig, ax = plt.subplots(figsize=(8,4))\n",
    "    ax.plot(df.index, df[\"Close\"], marker=\"o\", linewidth=1)\n",
    "    ax.set_title(title)\n",
    "    ax.set_xlabel(\"Date\")\n",
    "    ax.set_ylabel(\"Close\")\n",
    "    ax.grid(True)\n",
    "    fig.autofmt_xdate()\n",
    "    buf = BytesIO()\n",
    "    plt.tight_layout()\n",
    "    fig.savefig(buf, format=\"png\", dpi=120)\n",
    "    plt.close(fig)\n",
    "    buf.seek(0)\n",
    "    return buf\n",
    "\n",
    "def currency_symbol_for(used_symbol: str) -> str:\n",
    "    if not used_symbol:\n",
    "        return \"\"\n",
    "    s = used_symbol.upper()\n",
    "    if s.endswith(\".NS\") or s.endswith(\".BO\"):\n",
    "        return \"‚Çπ\"\n",
    "    if s.endswith(\".L\"):\n",
    "        return \"¬£\"\n",
    "    if s.endswith(\".PA\") or s.endswith(\".DE\") or s.endswith(\".AS\") or s.endswith(\".SW\"):\n",
    "        return \"‚Ç¨\"\n",
    "    if s.endswith(\".HK\"):\n",
    "        return \"HK$\"\n",
    "    if s.endswith(\".TO\"):\n",
    "        return \"C$\"\n",
    "    if s.endswith(\".AX\"):\n",
    "        return \"A$\"\n",
    "    if s.endswith(\".T\"):\n",
    "        return \"¬•\"\n",
    "    if s.endswith(\".SI\"):\n",
    "        return \"S$\"\n",
    "    if s.endswith(\".SS\") or s.endswith(\".SZ\"):\n",
    "        return \"¬•\"\n",
    "    return \"$\"  # default\n",
    "\n",
    "# ---------------- PREPARE DATASETS ----------------\n",
    "if not try_download(NIFTY50_URL, NIFTY50_FILE):\n",
    "    nifty50_df = pd.DataFrame([\n",
    "        {\"SYMBOL\":\"RELIANCE\",\"NAME\":\"reliance industries limited\"},\n",
    "        {\"SYMBOL\":\"TCS\",\"NAME\":\"tata consultancy services limited\"},\n",
    "        {\"SYMBOL\":\"INFY\",\"NAME\":\"infosys limited\"},\n",
    "        {\"SYMBOL\":\"HDFCBANK\",\"NAME\":\"hdfc bank limited\"},\n",
    "        {\"SYMBOL\":\"ITC\",\"NAME\":\"itc limited\"}\n",
    "    ])\n",
    "else:\n",
    "    nifty50_df = load_index_csv(NIFTY50_FILE)\n",
    "\n",
    "if not try_download(NIFTY500_URL, NIFTY500_FILE):\n",
    "    nifty500_df = pd.DataFrame([\n",
    "        {\"SYMBOL\":\"RELIANCE\",\"NAME\":\"reliance industries limited\"},\n",
    "        {\"SYMBOL\":\"TCS\",\"NAME\":\"tata consultancy services limited\"},\n",
    "        {\"SYMBOL\":\"ZOMATO\",\"NAME\":\"zomato limited\"},\n",
    "        {\"SYMBOL\":\"KNRCON\",\"NAME\":\"knr constructions limited\"},\n",
    "        {\"SYMBOL\":\"IIL\",\"NAME\":\"iil limited\"}\n",
    "    ])\n",
    "else:\n",
    "    nifty500_df = load_index_csv(NIFTY500_FILE)\n",
    "\n",
    "all_df = pd.concat([nifty50_df, nifty500_df], ignore_index=True)\\\n",
    "           .drop_duplicates(subset=\"SYMBOL\").reset_index(drop=True)\n",
    "\n",
    "# ---------------- RESOLUTION: name ‚Üí ticker with fuzzy suggestions ----------------\n",
    "def normalize_text(s: str) -> str:\n",
    "    return re.sub(r\"\\s+\", \" \", s.strip().lower())\n",
    "\n",
    "def lookup_name_map(query: str):\n",
    "    key = normalize_text(query)\n",
    "    return NAME_TICKER.get(key)\n",
    "\n",
    "def fuzzy_suggestions(query: str, k=7, cutoff=0.65):\n",
    "    q = normalize_text(query)\n",
    "    map_names = list(NAME_TICKER.keys())\n",
    "    map_matches = difflib.get_close_matches(q, map_names, n=k, cutoff=cutoff)\n",
    "\n",
    "    suggestions = []\n",
    "    for name in map_matches:\n",
    "        suggestions.append((name.title(), NAME_TICKER[name], \"map\"))\n",
    "\n",
    "    nse_names = all_df[\"NAME\"].dropna().unique().tolist()\n",
    "    nse_matches = difflib.get_close_matches(q, nse_names, n=k, cutoff=cutoff)\n",
    "    for nm in nse_matches:\n",
    "        row = all_df.loc[all_df[\"NAME\"] == nm].head(1)\n",
    "        if not row.empty:\n",
    "            sym = row.iloc[0][\"SYMBOL\"]\n",
    "            suggestions.append((nm.title(), sym + \".NS\", \"nse\"))\n",
    "\n",
    "    # De-duplicate while preserving order\n",
    "    seen = set()\n",
    "    deduped = []\n",
    "    for disp, tick, src in suggestions:\n",
    "        key = (disp.lower(), tick.upper())\n",
    "        if key not in seen:\n",
    "            seen.add(key)\n",
    "            deduped.append((disp, tick, src))\n",
    "    return deduped[:k]\n",
    "\n",
    "# ---------------- SEARCH FUNCTION (kept for NSE lists) ----------------\n",
    "def search_companies(query, max_results=10):\n",
    "    q = str(query).strip()\n",
    "    if not q:\n",
    "        return []\n",
    "    q_low = q.lower()\n",
    "    exact = all_df[all_df[\"SYMBOL\"] == q.upper()]\n",
    "    results = []\n",
    "    if not exact.empty:\n",
    "        for _, r in exact.iterrows():\n",
    "            results.append((r[\"SYMBOL\"], r[\"NAME\"]))\n",
    "        return results[:max_results]\n",
    "    mask = all_df[\"NAME\"].str.contains(q_low, na=False)\n",
    "    filtered = all_df[mask].head(max_results)\n",
    "    for _, r in filtered.iterrows():\n",
    "        results.append((r[\"SYMBOL\"], r[\"NAME\"]))\n",
    "    return results\n",
    "\n",
    "# ---------------- TICKER PROBE (multi-exchange) ----------------\n",
    "COMMON_SUFFIXES = [\n",
    "    \".NS\", \".BO\",  # India\n",
    "    \".L\", \".DE\", \".PA\", \".AS\", \".SW\",  # UK/DE/FR/NL/CH\n",
    "    \".HK\", \".TO\", \".AX\", \".SI\", \".T\",  # HK/Canada/Australia/Singapore/Japan\n",
    "    \".SS\", \".SZ\"  # China\n",
    "]\n",
    "INDEX_MAP = {\"NIFTY\":\"^NSEI\",\"NIFTY50\":\"^NSEI\",\"BANKNIFTY\":\"^NSEBANK\",\"NIFTYBANK\":\"^NSEBANK\"}\n",
    "\n",
    "def probe_yf_symbol(symbol):\n",
    "    symbol = symbol.strip().upper()\n",
    "\n",
    "    # Indices\n",
    "    if symbol in INDEX_MAP:\n",
    "        try:\n",
    "            t = yf.Ticker(INDEX_MAP[symbol])\n",
    "            if not t.history(period=\"1d\").empty:\n",
    "                return t, INDEX_MAP[symbol]\n",
    "        except:\n",
    "            pass\n",
    "\n",
    "    # Try raw first (for US/global)\n",
    "    try:\n",
    "        t = yf.Ticker(symbol)\n",
    "        if not t.history(period=\"3d\").empty:\n",
    "            return t, symbol\n",
    "    except:\n",
    "        pass\n",
    "\n",
    "    # NSE/BSE\n",
    "    for cand in (symbol + \".NS\", symbol + \".BO\"):\n",
    "        try:\n",
    "            t = yf.Ticker(cand)\n",
    "            if not t.history(period=\"3d\").empty:\n",
    "                return t, cand\n",
    "        except:\n",
    "            pass\n",
    "\n",
    "    # Other common suffixes\n",
    "    for suf in COMMON_SUFFIXES:\n",
    "        cand = symbol + suf\n",
    "        try:\n",
    "            t = yf.Ticker(cand)\n",
    "            if not t.history(period=\"3d\").empty:\n",
    "                return t, cand\n",
    "        except:\n",
    "            pass\n",
    "\n",
    "    return None, None\n",
    "\n",
    "# ---------------- MENUS ----------------\n",
    "def main_menu_keyboard():\n",
    "    kb = types.ReplyKeyboardMarkup(resize_keyboard=True)\n",
    "    kb.add(\"üìà Stocks\", \"üí∞ Invest\")\n",
    "    kb.add(\"üîç Search Again\")\n",
    "    return kb\n",
    "\n",
    "# ---------------- TELEGRAM HANDLERS ----------------\n",
    "@bot.message_handler(commands=[\"start\",\"help\"])\n",
    "def cmd_start(msg):\n",
    "    bot.send_message(\n",
    "        msg.chat.id,\n",
    "        \"Welcome! Choose:\\n‚Ä¢ üìà Stocks: Search tickers, charts, insights + BS/Ratios/Peers/Pros&Cons\\n‚Ä¢ üí∞ Invest: Plan allocation with pie chart\",\n",
    "        reply_markup=main_menu_keyboard()\n",
    "    )\n",
    "    chat_state[msg.chat.id] = {\"stage\":\"await_query\"}  # default to Stocks search mode\n",
    "\n",
    "@bot.message_handler(func=lambda m: m.text == \"üìà Stocks\")\n",
    "def cmd_stocks(msg):\n",
    "    chat_state[msg.chat.id] = {\"stage\":\"await_query\"}  # switch to stocks mode\n",
    "    bot.send_message(msg.chat.id, \"Type company name or ticker (e.g., apple, tesla, reliance, tcs).\")\n",
    "\n",
    "@bot.message_handler(func=lambda m: m.text == \"üí∞ Invest\")\n",
    "def cmd_invest(msg):\n",
    "    chat_state[msg.chat.id] = {\"mode\":\"invest\", \"invest_stage\":\"await_amount\"}\n",
    "    bot.send_message(msg.chat.id, \"Enter the amount you want to invest (in ‚Çπ):\")\n",
    "\n",
    "# ‚úÖ FIX: make reply-keyboard 'Search Again' robust (emoji or no emoji)\n",
    "@bot.message_handler(func=lambda m: m.text and m.text.strip().lower().replace(\"üîç\",\"\").strip() == \"search again\")\n",
    "def cmd_search_again(msg):\n",
    "    state = chat_state.get(msg.chat.id, {})\n",
    "    if state.get(\"mode\") == \"invest\":\n",
    "        chat_state[msg.chat.id] = {\"mode\":\"invest\", \"invest_stage\":\"await_amount\"}\n",
    "        bot.send_message(msg.chat.id, \"Okay ‚Äî enter the amount again (‚Çπ):\")\n",
    "    else:\n",
    "        chat_state[msg.chat.id] = {\"stage\":\"await_query\"}\n",
    "        bot.send_message(msg.chat.id, \"Okay ‚Äî type company name or symbol to search:\")\n",
    "\n",
    "def build_suggestion_markup(suggestions):\n",
    "    markup = types.InlineKeyboardMarkup()\n",
    "    for disp, tick, src in suggestions:\n",
    "        show = f\"{disp} ({tick})\"\n",
    "        markup.add(types.InlineKeyboardButton(show, callback_data=f\"choose|{tick}\"))\n",
    "    markup.add(types.InlineKeyboardButton(\"üîç Search Again\", callback_data=\"search_again\"))\n",
    "    return markup\n",
    "\n",
    "# ---------------- INVESTMENT FLOW: amount message handler ----------------\n",
    "@bot.message_handler(func=lambda m: chat_state.get(m.chat.id,{}).get(\"mode\")==\"invest\" and chat_state.get(m.chat.id,{}).get(\"invest_stage\")==\"await_amount\")\n",
    "def handle_invest_amount(msg):\n",
    "    chat_id = msg.chat.id\n",
    "    txt = (msg.text or \"\").strip().replace(\",\",\"\")\n",
    "    try:\n",
    "        amount = float(txt)\n",
    "        if amount <= 0:\n",
    "            raise ValueError(\"non-positive\")\n",
    "        chat_state[chat_id][\"amount\"] = amount\n",
    "        chat_state[chat_id][\"invest_stage\"] = \"await_risk\"\n",
    "        markup = types.InlineKeyboardMarkup()\n",
    "        markup.add(types.InlineKeyboardButton(\"Low\", callback_data=\"risk_low\"),\n",
    "                   types.InlineKeyboardButton(\"Medium\", callback_data=\"risk_medium\"),\n",
    "                   types.InlineKeyboardButton(\"High\", callback_data=\"risk_high\"))\n",
    "        bot.send_message(chat_id, \"Select your risk preference:\", reply_markup=markup)\n",
    "    except Exception:\n",
    "        bot.send_message(chat_id, \"‚ùå Please enter a valid positive number (e.g., 15000).\")\n",
    "\n",
    "# ---------------- STOCKS FLOW: free text search handler ----------------\n",
    "@bot.message_handler(func=lambda m: chat_state.get(m.chat.id,{}).get(\"stage\")==\"await_query\")\n",
    "def handle_query(msg):\n",
    "    chat_id = msg.chat.id\n",
    "    q = msg.text.strip()\n",
    "    bot.send_chat_action(chat_id, \"typing\")\n",
    "\n",
    "    mapped = lookup_name_map(q)\n",
    "    if mapped:\n",
    "        matches = [(mapped.replace(\".NS\",\"\").replace(\".BO\",\"\"), mapped)]\n",
    "    else:\n",
    "        matches_raw = search_companies(q, max_results=10)\n",
    "        matches = []\n",
    "        for sym, name in matches_raw:\n",
    "            matches.append((sym, f\"{name}\"))\n",
    "        if not matches:\n",
    "            t, used = probe_yf_symbol(q)\n",
    "            if t:\n",
    "                matches = [(used.replace(\".NS\",\"\").replace(\".BO\",\"\"), used)]\n",
    "\n",
    "    if not matches:\n",
    "        suggestions = fuzzy_suggestions(q, k=7, cutoff=0.6)\n",
    "        if suggestions:\n",
    "            bot.send_message(\n",
    "                chat_id,\n",
    "                \"‚ùì I couldn't find an exact match. Did you mean one of these?\",\n",
    "                reply_markup=build_suggestion_markup(suggestions)\n",
    "            )\n",
    "        else:\n",
    "            bot.send_message(\n",
    "                chat_id,\n",
    "                \"‚ùå No matches found. Try another name/symbol (e.g., *Apple*, *Tesla*, *Reliance*, *TCS*).\",\n",
    "                parse_mode=\"Markdown\"\n",
    "            )\n",
    "        chat_state[chat_id] = {\"stage\":\"await_query\"}\n",
    "        return\n",
    "\n",
    "    chat_state[chat_id] = {\"stage\":\"choose\", \"matches\":matches}\n",
    "    markup = types.InlineKeyboardMarkup()\n",
    "    for sym, name in matches:\n",
    "        display = f\"{name} ({sym})\"\n",
    "        markup.add(types.InlineKeyboardButton(display, callback_data=f\"choose|{sym}\"))\n",
    "    markup.add(types.InlineKeyboardButton(\"üîç Search Again\", callback_data=\"search_again\"))\n",
    "    bot.send_message(chat_id, \"Select the correct company:\", reply_markup=markup)\n",
    "\n",
    "# ---------------- CALLBACK ROUTER (Stocks & Invest inline buttons) ----------------\n",
    "@bot.callback_query_handler(func=lambda call: True)\n",
    "def callback_router(call):\n",
    "    data = call.data\n",
    "    chat_id = call.message.chat.id\n",
    "    bot.answer_callback_query(call.id)\n",
    "\n",
    "    # Common inline 'Search Again'\n",
    "    if data == \"search_again\":\n",
    "        state = chat_state.get(chat_id, {})\n",
    "        if state.get(\"mode\") == \"invest\":\n",
    "            chat_state[chat_id] = {\"mode\":\"invest\", \"invest_stage\":\"await_amount\"}\n",
    "            bot.send_message(chat_id, \"Search again ‚Äî enter amount (‚Çπ):\", reply_markup=main_menu_keyboard())\n",
    "        else:\n",
    "            chat_state[chat_id] = {\"stage\":\"await_query\"}\n",
    "            bot.send_message(chat_id, \"Search again ‚Äî type company name or symbol.\", reply_markup=main_menu_keyboard())\n",
    "        return\n",
    "\n",
    "    # ---------------- INVEST FLOW BUTTONS ----------------\n",
    "    if data.startswith(\"risk_\"):\n",
    "        risk = data.split(\"_\",1)[1]  # low/medium/high\n",
    "        st = chat_state.get(chat_id, {})\n",
    "        if st.get(\"mode\") == \"invest\":\n",
    "            st[\"risk\"] = risk\n",
    "            st[\"invest_stage\"] = \"await_choice\"\n",
    "            markup = types.InlineKeyboardMarkup()\n",
    "            markup.add(types.InlineKeyboardButton(\"üìÇ Diversify\", callback_data=\"invest_diversify\"),\n",
    "                       types.InlineKeyboardButton(\"üéØ Single\", callback_data=\"invest_single\"))\n",
    "            bot.send_message(chat_id, \"Diversify portfolio or invest in a single option?\", reply_markup=markup)\n",
    "            return\n",
    "\n",
    "    if data in (\"invest_diversify\", \"invest_single\"):\n",
    "        st = chat_state.get(chat_id, {})\n",
    "        if st.get(\"mode\") == \"invest\":\n",
    "            amount = float(st.get(\"amount\", 0))\n",
    "            risk = st.get(\"risk\", \"medium\")\n",
    "            if amount <= 0:\n",
    "                st[\"invest_stage\"] = \"await_amount\"\n",
    "                bot.send_message(chat_id, \"‚ùå Amount missing. Enter amount (‚Çπ):\")\n",
    "                return\n",
    "\n",
    "            if data == \"invest_diversify\":\n",
    "                plan = generate_allocation_plan(risk)\n",
    "                text = \"üìä Diversified Portfolio:\\n\"\n",
    "                for k, v in plan.items():\n",
    "                    text += f\"- {int(v*100)}% (‚Çπ{int(round(amount*v))}) ‚Üí {k}\\n\"\n",
    "                bot.send_message(chat_id, text)\n",
    "                pie_buf = create_pie_chart_bytes(plan, title=\"Investment Allocation\")\n",
    "                bot.send_photo(chat_id, pie_buf)\n",
    "            else:\n",
    "                option = single_invest_option(risk)\n",
    "                text = f\"üéØ Single Investment Choice:\\nInvest ‚Çπ{int(round(amount))} fully into {option}\"\n",
    "                bot.send_message(chat_id, text)\n",
    "\n",
    "            markup = types.InlineKeyboardMarkup()\n",
    "            markup.add(types.InlineKeyboardButton(\"üîÑ Recalculate\", callback_data=\"invest_recalc\"))\n",
    "            markup.add(types.InlineKeyboardButton(\"üè† Main Menu\", callback_data=\"go_home\"))\n",
    "            bot.send_message(chat_id, \"Do you want to try again?\", reply_markup=markup)\n",
    "            return\n",
    "\n",
    "    if data == \"invest_recalc\":\n",
    "        chat_state[chat_id] = {\"mode\":\"invest\", \"invest_stage\":\"await_amount\"}\n",
    "        bot.send_message(chat_id, \"Enter the amount you want to invest (‚Çπ):\")\n",
    "        return\n",
    "\n",
    "    if data == \"go_home\":\n",
    "        chat_state[chat_id] = {\"stage\":\"await_query\"}\n",
    "        bot.send_message(chat_id, \"Back to main menu. Choose an option:\", reply_markup=main_menu_keyboard())\n",
    "        return\n",
    "\n",
    "    # ---------------- STOCKS FLOW BUTTONS ----------------\n",
    "    if data.startswith(\"choose|\"):\n",
    "        sym = data.split(\"|\",1)[1]\n",
    "        chat_state[chat_id] = {\"stage\":\"selected\", \"symbol\":sym}\n",
    "        markup = types.InlineKeyboardMarkup()\n",
    "        # Existing\n",
    "        markup.add(types.InlineKeyboardButton(\"üìú 7-Day History + Chart\", callback_data=f\"action|history7|{sym}\"))\n",
    "        markup.add(types.InlineKeyboardButton(\"üìä 30-Day Chart\", callback_data=f\"action|chart30|{sym}\"))\n",
    "        markup.add(types.InlineKeyboardButton(\"ü§ñ Insights\", callback_data=f\"action|insights|{sym}\"))\n",
    "        # New\n",
    "        markup.add(types.InlineKeyboardButton(\"üìÑ Balance Sheet\", callback_data=f\"action|balance|{sym}\"))\n",
    "        markup.add(types.InlineKeyboardButton(\"üìä Ratios\", callback_data=f\"action|ratios|{sym}\"))\n",
    "        markup.add(types.InlineKeyboardButton(\"üè¢ Peer Comparison\", callback_data=f\"action|peers|{sym}\"))\n",
    "        markup.add(types.InlineKeyboardButton(\"‚úÖ Pros & Cons\", callback_data=f\"action|proscons|{sym}\"))\n",
    "        markup.add(types.InlineKeyboardButton(\"üîç Search Again\", callback_data=\"search_again\"))\n",
    "        bot.send_message(chat_id, f\"Selected: {sym}\\nChoose action:\", reply_markup=markup)\n",
    "        return\n",
    "\n",
    "    if data.startswith(\"action|\"):\n",
    "        _, action, sym = data.split(\"|\",2)\n",
    "        base_sym = sym\n",
    "        if action == \"history7\":\n",
    "            send_history_and_chart(chat_id, base_sym, days=7)\n",
    "        elif action == \"chart30\":\n",
    "            send_history_and_chart(chat_id, base_sym, days=30, only_chart=True)\n",
    "        elif action == \"insights\":\n",
    "            send_ai_insight(chat_id, base_sym)\n",
    "        elif action == \"balance\":\n",
    "            send_balance_sheet(chat_id, base_sym)\n",
    "        elif action == \"ratios\":\n",
    "            send_ratios(chat_id, base_sym)\n",
    "        elif action == \"peers\":\n",
    "            send_peer_comparison(chat_id, base_sym)\n",
    "        elif action == \"proscons\":\n",
    "            send_pros_cons(chat_id, base_sym)\n",
    "        return\n",
    "\n",
    "# ---------------- INVESTMENT HELPERS ----------------\n",
    "def generate_allocation_plan(risk: str):\n",
    "    risk = (risk or \"medium\").lower()\n",
    "    if risk == \"low\":\n",
    "        return {\"FD & Bonds\": 0.6, \"Index Fund\": 0.3, \"Gold ETF\": 0.1}\n",
    "    elif risk == \"high\":\n",
    "        return {\"Equity (Mid & Small Cap)\": 0.5, \"Crypto\": 0.3, \"Tech ETF\": 0.2}\n",
    "    else:\n",
    "        return {\"Nifty 50 Index Fund\": 0.5, \"Gold ETF\": 0.3, \"Large-cap stocks\": 0.2}\n",
    "\n",
    "def single_invest_option(risk: str):\n",
    "    risk = (risk or \"medium\").lower()\n",
    "    if risk == \"low\": return \"Index Fund\"\n",
    "    if risk == \"high\": return \"Crypto\"\n",
    "    return \"Gold ETF\"\n",
    "\n",
    "def create_pie_chart_bytes(plan: dict, title=\"Investment Allocation\"):\n",
    "    labels = list(plan.keys())\n",
    "    sizes = list(plan.values())\n",
    "    fig, ax = plt.subplots(figsize=(5,5))\n",
    "    ax.pie(sizes, labels=labels, autopct=\"%1.1f%%\", startangle=140)\n",
    "    ax.set_title(title)\n",
    "    ax.axis(\"equal\")\n",
    "    buf = BytesIO()\n",
    "    plt.tight_layout()\n",
    "    fig.savefig(buf, format=\"png\", dpi=140)\n",
    "    plt.close(fig)\n",
    "    buf.seek(0)\n",
    "    return buf\n",
    "\n",
    "# ---------------- DATA RESPONSES (STOCKS) ----------------\n",
    "def fetch_ticker(symbol):\n",
    "    t, used = probe_yf_symbol(symbol)\n",
    "    return t, used\n",
    "\n",
    "def send_history_and_chart(chat_id, symbol, days=7, only_chart=False):\n",
    "    t, used = fetch_ticker(symbol)\n",
    "    if t is None:\n",
    "        bot.send_message(chat_id, f\"‚ùå Market data not found for {symbol}.\")\n",
    "        return search_again_prompt(chat_id)\n",
    "\n",
    "    hist = t.history(period=f\"{days}d\")\n",
    "    if hist.empty:\n",
    "        bot.send_message(chat_id, f\"‚ùå No historical data for {symbol} ({used}).\")\n",
    "        return search_again_prompt(chat_id)\n",
    "\n",
    "    if days == 7 and not only_chart:\n",
    "        ccy = currency_symbol_for(used)\n",
    "        header = f\"üìú *{days}-Day Price History for {symbol}* (symbol: {used})\\n\"\n",
    "        fmt = \"{:<10} {:>10} {:>10} {:>10} {:>10} {:>10}\"\n",
    "        lines = [fmt.format(\"Date\",\"Open\",\"High\",\"Low\",\"Close\",\"Volume\")]\n",
    "        for idx,row in hist.iterrows():\n",
    "            d = idx.strftime(\"%Y-%m-%d\")\n",
    "            o = f\"{ccy}{row['Open']:.2f}\"\n",
    "            h = f\"{ccy}{row['High']:.2f}\"\n",
    "            l = f\"{ccy}{row['Low']:.2f}\"\n",
    "            c = f\"{ccy}{row['Close']:.2f}\"\n",
    "            v = human_volume(row['Volume']) if 'Volume' in row else str(row.get('Volume',''))\n",
    "            lines.append(fmt.format(d,o,h,l,c,v))\n",
    "        msg = header + \"```\\n\" + \"\\n\".join(lines) + \"\\n```\"\n",
    "        bot.send_message(chat_id, msg, parse_mode=\"Markdown\")\n",
    "\n",
    "    buf = create_chart_bytes(hist.tail(30), f\"{symbol} - Last {days} Days\")\n",
    "    bot.send_photo(chat_id, buf)\n",
    "    return search_again_prompt(chat_id)\n",
    "\n",
    "def bulletize_news_item(item):\n",
    "    title = item.get(\"title\", \"\").strip()\n",
    "    publisher = item.get(\"publisher\") or item.get(\"source\") or \"\"\n",
    "    ts = item.get(\"providerPublishTime\")\n",
    "    when = \"\"\n",
    "    try:\n",
    "        if ts:\n",
    "            when = datetime.fromtimestamp(int(ts)).strftime(\"%Y-%m-%d\")\n",
    "    except Exception:\n",
    "        pass\n",
    "\n",
    "    summary = item.get(\"summary\", \"\") or item.get(\"content\", \"\")\n",
    "    bullets = []\n",
    "    if summary:\n",
    "        parts = re.split(r\"(?<=[.!?])\\s+\", summary)\n",
    "        for s in parts[:2]:\n",
    "            s = s.strip()\n",
    "            if s:\n",
    "                bullets.append(f\"- {s}\")\n",
    "    else:\n",
    "        if title:\n",
    "            bullets.append(f\"- {title}\")\n",
    "\n",
    "    context = []\n",
    "    if publisher: context.append(publisher)\n",
    "    if when: context.append(when)\n",
    "    ctx = \" ¬∑ \".join(context)\n",
    "    return bullets, ctx\n",
    "\n",
    "def send_ai_insight(chat_id, symbol):\n",
    "    t, used = fetch_ticker(symbol)\n",
    "    if t is None:\n",
    "        bot.send_message(chat_id, f\"‚ùå Market data not found for {symbol}.\")\n",
    "        return search_again_prompt(chat_id)\n",
    "\n",
    "    hist = t.history(period=\"1mo\")\n",
    "    if hist.empty or len(hist) < 5:\n",
    "        bot.send_message(chat_id, f\"‚ùå Not enough data for insights on {symbol}.\")\n",
    "        return search_again_prompt(chat_id)\n",
    "\n",
    "    close = hist[\"Close\"]\n",
    "    ma20 = close.rolling(window=20).mean().iloc[-1] if len(close) >= 20 else close.mean()\n",
    "    ma50 = close.rolling(window=50).mean().iloc[-1] if len(close) >= 50 else close.mean()\n",
    "    rsi_series = compute_rsi(close)\n",
    "    rsi_latest = rsi_series.iloc[-1] if not rsi_series.empty else float('nan')\n",
    "    last_price = close.iloc[-1]\n",
    "    first_price = close.iloc[0]\n",
    "    pct_1m = (last_price - first_price) / first_price * 100\n",
    "\n",
    "    ccy = currency_symbol_for(used)\n",
    "\n",
    "    suggestion = \"HOLD\"\n",
    "    reasons = []\n",
    "    if ma20 and ma50 and ma20 > ma50 and (not math.isnan(rsi_latest) and rsi_latest < 70):\n",
    "        suggestion = \"BUY\"; reasons.append(\"MA20 > MA50\")\n",
    "    if ma20 and ma50 and ma20 < ma50:\n",
    "        if suggestion != \"BUY\":\n",
    "            suggestion = \"SELL\"; reasons.append(\"MA20 < MA50\")\n",
    "    if not math.isnan(rsi_latest):\n",
    "        if rsi_latest > 70:\n",
    "            suggestion = \"SELL\"; reasons.append(\"RSI > 70 (overbought)\")\n",
    "        elif rsi_latest < 30:\n",
    "            suggestion = \"BUY\"; reasons.append(\"RSI < 30 (oversold)\")\n",
    "\n",
    "    lines = [\n",
    "        f\"ü§ñ *AI Insights for {symbol}*\",\n",
    "        f\"‚Ä¢ Last price: {ccy}{last_price:.2f}\",\n",
    "        f\"‚Ä¢ 1-month change: {pct_1m:.2f}%\",\n",
    "        f\"‚Ä¢ MA20: {ccy}{ma20:.2f}  |  MA50: {ccy}{ma50:.2f}\",\n",
    "        (f\"‚Ä¢ RSI: {rsi_latest:.2f}\" if not math.isnan(rsi_latest) else \"‚Ä¢ RSI: N/A\"),\n",
    "        \"\",\n",
    "        f\"*Suggestion: {suggestion}*\"\n",
    "    ]\n",
    "    if reasons:\n",
    "        lines.append(\"‚Ä¢ Reasons: \" + \"; \".join(reasons))\n",
    "\n",
    "    news_text = \"\"\n",
    "    try:\n",
    "        news_items = t.news\n",
    "        if news_items:\n",
    "            news_text = \"\\n\\nüì∞ *Latest news (highlights):*\\n\"\n",
    "            for n in news_items[:3]:\n",
    "                title = n.get(\"title\",\"news\")\n",
    "                link = n.get(\"link\")\n",
    "                bullets, ctx = bulletize_news_item(n)\n",
    "                if link:\n",
    "                    news_text += f\"‚Ä¢ [{title}]({link})\"\n",
    "                else:\n",
    "                    news_text += f\"‚Ä¢ {title}\"\n",
    "                if ctx:\n",
    "                    news_text += f\" _( {ctx} )_\"\n",
    "                news_text += \"\\n\"\n",
    "                for b in bullets[:2]:\n",
    "                    news_text += f\"   {b}\\n\"\n",
    "    except Exception:\n",
    "        news_text = \"\\n\\n(No news available)\"\n",
    "\n",
    "    final_msg = \"\\n\".join(lines) + (news_text if news_text else \"\")\n",
    "    bot.send_message(chat_id, final_msg, parse_mode=\"Markdown\", disable_web_page_preview=True)\n",
    "    return search_again_prompt(chat_id)\n",
    "\n",
    "# ---------------- NEW: Balance Sheet / Ratios / Peers / Pros & Cons ----------------\n",
    "def send_balance_sheet(chat_id, symbol):\n",
    "    t, used = fetch_ticker(symbol)\n",
    "    if t is None:\n",
    "        bot.send_message(chat_id, f\"‚ùå Could not load data for {symbol}.\")\n",
    "        return search_again_prompt(chat_id)\n",
    "    try:\n",
    "        bs = t.balance_sheet\n",
    "        if bs is None or bs.empty:\n",
    "            bot.send_message(chat_id, f\"üìÑ Balance Sheet not available for {used}.\")\n",
    "            return search_again_prompt(chat_id)\n",
    "        # Show the latest column, top rows\n",
    "        latest_col = bs.columns[0]\n",
    "        rows_to_show = min(12, len(bs.index))\n",
    "        subset = bs.iloc[:rows_to_show, [0]].copy()\n",
    "        subset.columns = [latest_col.strftime(\"%Y-%m-%d\") if hasattr(latest_col, \"strftime\") else str(latest_col)]\n",
    "        # Format\n",
    "        lines = [f\"üìÑ *Balance Sheet (latest)* ‚Äî {symbol} ({used})\"]\n",
    "        for idx, val in subset.iloc[:,0].items():\n",
    "            lines.append(f\"- {idx}: {human_number(val)}\")\n",
    "        bot.send_message(chat_id, \"\\n\".join(lines), parse_mode=\"Markdown\")\n",
    "    except Exception:\n",
    "        bot.send_message(chat_id, f\"üìÑ Balance Sheet not available for {used}.\")\n",
    "    return search_again_prompt(chat_id)\n",
    "\n",
    "def collect_ratios(t):\n",
    "    \"\"\"Pull a bunch of ratios with safe defaults.\"\"\"\n",
    "    info = {}\n",
    "    try:\n",
    "        info = t.info or {}\n",
    "    except Exception:\n",
    "        info = {}\n",
    "\n",
    "    def g(key, default=None):\n",
    "        v = info.get(key, default)\n",
    "        return v\n",
    "\n",
    "    ratios = {\n",
    "        \"Price\": g(\"currentPrice\"),\n",
    "        \"P/E (trailing)\": g(\"trailingPE\"),\n",
    "        \"P/E (forward)\": g(\"forwardPE\"),\n",
    "        \"P/B\": g(\"priceToBook\"),\n",
    "        \"ROE\": g(\"returnOnEquity\"),\n",
    "        \"ROA\": g(\"returnOnAssets\"),\n",
    "        \"Profit Margin\": g(\"profitMargins\"),\n",
    "        \"Operating Margin\": g(\"operatingMargins\"),\n",
    "        \"Debt/Equity\": g(\"debtToEquity\"),\n",
    "        \"Market Cap\": g(\"marketCap\"),\n",
    "        \"Beta\": g(\"beta\"),\n",
    "        \"Revenue Growth\": g(\"revenueGrowth\"),\n",
    "        \"EBITDA Margins\": g(\"ebitdaMargins\"),\n",
    "        \"Industry\": g(\"industry\"),\n",
    "        \"Sector\": g(\"sector\"),\n",
    "        \"Currency\": g(\"currency\")\n",
    "    }\n",
    "    return ratios\n",
    "\n",
    "def send_ratios(chat_id, symbol):\n",
    "    t, used = fetch_ticker(symbol)\n",
    "    if t is None:\n",
    "        bot.send_message(chat_id, f\"‚ùå Could not load data for {symbol}.\")\n",
    "        return search_again_prompt(chat_id)\n",
    "    ratios = collect_ratios(t)\n",
    "    lines = [f\"üìä *Key Ratios* ‚Äî {symbol} ({used})\"]\n",
    "    def fmt_ratio(label, val, is_pct=False):\n",
    "        if val is None or val == 0:\n",
    "            return f\"- {label}: ‚Äî\"\n",
    "        if is_pct:\n",
    "            return f\"- {label}: {pct(val)}\"\n",
    "        if label in (\"Market Cap\",\"Price\"):\n",
    "            return f\"- {label}: {human_number(val)}\"\n",
    "        return f\"- {label}: {val:.2f}\" if isinstance(val, (int, float)) else f\"- {label}: {val}\"\n",
    "\n",
    "    lines.append(fmt_ratio(\"Price\", ratios[\"Price\"]))\n",
    "    lines.append(fmt_ratio(\"P/E (trailing)\", ratios[\"P/E (trailing)\"]))\n",
    "    lines.append(fmt_ratio(\"P/E (forward)\", ratios[\"P/E (forward)\"]))\n",
    "    lines.append(fmt_ratio(\"P/B\", ratios[\"P/B\"]))\n",
    "    lines.append(fmt_ratio(\"ROE\", ratios[\"ROE\"], is_pct=True))\n",
    "    lines.append(fmt_ratio(\"ROA\", ratios[\"ROA\"], is_pct=True))\n",
    "    lines.append(fmt_ratio(\"Profit Margin\", ratios[\"Profit Margin\"], is_pct=True))\n",
    "    lines.append(fmt_ratio(\"Operating Margin\", ratios[\"Operating Margin\"], is_pct=True))\n",
    "    lines.append(fmt_ratio(\"Revenue Growth\", ratios[\"Revenue Growth\"], is_pct=True))\n",
    "    lines.append(fmt_ratio(\"EBITDA Margins\", ratios[\"EBITDA Margins\"], is_pct=True))\n",
    "    lines.append(fmt_ratio(\"Debt/Equity\", ratios[\"Debt/Equity\"]))\n",
    "    lines.append(fmt_ratio(\"Market Cap\", ratios[\"Market Cap\"]))\n",
    "    if ratios[\"Sector\"]: lines.append(f\"- Sector: {ratios['Sector']}\")\n",
    "    if ratios[\"Industry\"]: lines.append(f\"- Industry: {ratios['Industry']}\")\n",
    "    if ratios[\"Currency\"]: lines.append(f\"- Currency: {ratios['Currency']}\")\n",
    "    bot.send_message(chat_id, \"\\n\".join(lines), parse_mode=\"Markdown\")\n",
    "    return search_again_prompt(chat_id)\n",
    "\n",
    "def candidate_universe_for(symbol):\n",
    "    s = symbol.upper()\n",
    "    if s.endswith(\".NS\") or s.endswith(\".BO\"):\n",
    "        return INDIA_LARGE_UNIVERSE\n",
    "    # default to US large caps for others\n",
    "    return US_LARGE_UNIVERSE\n",
    "\n",
    "def send_peer_comparison(chat_id, symbol):\n",
    "    t, used = fetch_ticker(symbol)\n",
    "    if t is None:\n",
    "        bot.send_message(chat_id, f\"‚ùå Could not load data for {symbol}.\")\n",
    "        return search_again_prompt(chat_id)\n",
    "\n",
    "    # Base company info\n",
    "    try:\n",
    "        base_info = t.info or {}\n",
    "    except Exception:\n",
    "        base_info = {}\n",
    "    base_sector = base_info.get(\"sector\")\n",
    "    base_industry = base_info.get(\"industry\")\n",
    "\n",
    "    # Build universe and filter by sector/industry\n",
    "    peers = []\n",
    "    universe = candidate_universe_for(used)\n",
    "    # ensure the main symbol is included\n",
    "    if used not in universe:\n",
    "        universe = [used] + universe\n",
    "\n",
    "    for tick in universe:\n",
    "        try:\n",
    "            ti = yf.Ticker(tick)\n",
    "            info = ti.info or {}\n",
    "            if (base_sector and info.get(\"sector\")==base_sector) or (base_industry and info.get(\"industry\")==base_industry) or (tick==used):\n",
    "                peers.append({\n",
    "                    \"ticker\": tick,\n",
    "                    \"price\": info.get(\"currentPrice\"),\n",
    "                    \"pe\": info.get(\"trailingPE\"),\n",
    "                    \"pb\": info.get(\"priceToBook\"),\n",
    "                    \"roe\": info.get(\"returnOnEquity\"),\n",
    "                    \"margin\": info.get(\"profitMargins\"),\n",
    "                    \"mcap\": info.get(\"marketCap\"),\n",
    "                    \"name\": info.get(\"shortName\") or info.get(\"longName\") or tick\n",
    "                })\n",
    "        except Exception:\n",
    "            continue\n",
    "\n",
    "    # Deduplicate and keep top 6 by market cap\n",
    "    uniq = {}\n",
    "    for p in peers:\n",
    "        uniq[p[\"ticker\"]] = p\n",
    "    peers = list(uniq.values())\n",
    "    peers = sorted(peers, key=lambda x: (x[\"ticker\"]!=used, -(x[\"mcap\"] or 0)))[:6]\n",
    "\n",
    "    if len(peers) <= 1:\n",
    "        bot.send_message(chat_id, \"üè¢ Peer data not sufficient to compare for this company.\")\n",
    "        return search_again_prompt(chat_id)\n",
    "\n",
    "    # Render as a neat monospace table\n",
    "    header = f\"üè¢ *Peer Comparison* ‚Äî base: {symbol} ({used})\"\n",
    "    fmt = \"{:<12} {:>10} {:>8} {:>8} {:>8} {:>9} {:>10}\"\n",
    "    lines = [header, \"```\\n\"+fmt.format(\"Ticker\",\"Price\",\"P/E\",\"P/B\",\"ROE%\",\"Margin%\",\"MktCap\")]\n",
    "    for p in peers:\n",
    "        lines.append(fmt.format(\n",
    "            p[\"ticker\"][:12],\n",
    "            human_number(p[\"price\"]) if p[\"price\"] else \"‚Äî\",\n",
    "            f\"{p['pe']:.2f}\" if isinstance(p[\"pe\"],(int,float)) else \"‚Äî\",\n",
    "            f\"{p['pb']:.2f}\" if isinstance(p[\"pb\"],(int,float)) else \"‚Äî\",\n",
    "            f\"{p['roe']*100:.1f}\" if isinstance(p[\"roe\"],(int,float)) else \"‚Äî\",\n",
    "            f\"{p['margin']*100:.1f}\" if isinstance(p[\"margin\"],(int,float)) else \"‚Äî\",\n",
    "            human_number(p[\"mcap\"]) if p[\"mcap\"] else \"‚Äî\"\n",
    "        ))\n",
    "    lines.append(\"```\")\n",
    "    bot.send_message(chat_id, \"\\n\".join(lines), parse_mode=\"Markdown\")\n",
    "    return search_again_prompt(chat_id)\n",
    "\n",
    "def send_pros_cons(chat_id, symbol):\n",
    "    t, used = fetch_ticker(symbol)\n",
    "    if t is None:\n",
    "        bot.send_message(chat_id, f\"‚ùå Could not load data for {symbol}.\")\n",
    "        return search_again_prompt(chat_id)\n",
    "\n",
    "    ratios = collect_ratios(t)\n",
    "    pros, cons = [], []\n",
    "\n",
    "    # ------- Heuristics (tweak thresholds as you wish) -------\n",
    "    rg = ratios.get(\"Revenue Growth\")\n",
    "    pm = ratios.get(\"Profit Margin\")\n",
    "    om = ratios.get(\"Operating Margin\")\n",
    "    roe = ratios.get(\"ROE\")\n",
    "    de = ratios.get(\"Debt/Equity\")\n",
    "    pe_f = ratios.get(\"P/E (forward)\")\n",
    "    pe_t = ratios.get(\"P/E (trailing)\")\n",
    "    pb = ratios.get(\"P/B\")\n",
    "    mcap = ratios.get(\"Market Cap\")\n",
    "    beta = ratios.get(\"Beta\")\n",
    "\n",
    "    if rg is not None and rg > 0: pros.append(\"Positive revenue growth\")\n",
    "    if pm is not None and pm > 0.10: pros.append(\"Healthy profit margins\")\n",
    "    if om is not None and om > 0.15: pros.append(\"Strong operating efficiency\")\n",
    "    if roe is not None and roe > 0.15: pros.append(\"High return on equity\")\n",
    "    if mcap is not None and mcap > 1e11: pros.append(\"Large market cap (relative stability)\")\n",
    "    if de is not None and de < 1: pros.append(\"Reasonable debt-to-equity\")\n",
    "\n",
    "    if rg is not None and rg < 0: cons.append(\"Declining revenues\")\n",
    "    if roe is not None and roe < 0.05: cons.append(\"Weak ROE\")\n",
    "    if pm is not None and pm < 0.05: cons.append(\"Thin profit margins\")\n",
    "    if de is not None and de > 2: cons.append(\"High leverage (Debt/Equity)\")\n",
    "    # Valuation flags: very high P/E or P/B relative flags\n",
    "    if (pe_f and isinstance(pe_f,(int,float)) and pe_f > 35) or (pe_t and isinstance(pe_t,(int,float)) and pe_t > 35):\n",
    "        cons.append(\"Rich valuation (high P/E)\")\n",
    "    if pb and isinstance(pb,(int,float)) and pb > 6:\n",
    "        cons.append(\"High price-to-book\")\n",
    "    if beta and isinstance(beta,(int,float)) and beta > 1.3:\n",
    "        cons.append(\"More volatile than market (high beta)\")\n",
    "\n",
    "    if not pros: pros = [\"No obvious strengths from public ratios\"]\n",
    "    if not cons: cons = [\"No major weaknesses flagged from ratios\"]\n",
    "\n",
    "    lines = [f\"‚úÖ *Pros & Cons* ‚Äî {symbol} ({used})\", \"*Pros:*\"]\n",
    "    lines += [f\"- {p}\" for p in pros]\n",
    "    lines += [\"\", \"*Cons:*\"]\n",
    "    lines += [f\"- {c}\" for c in cons]\n",
    "    bot.send_message(chat_id, \"\\n\".join(lines), parse_mode=\"Markdown\")\n",
    "    return search_again_prompt(chat_id)\n",
    "\n",
    "# ‚úÖ After each stocks action, keep user ready to query again\n",
    "def search_again_prompt(chat_id):\n",
    "    bot.send_message(chat_id, \"What next? Type a name or tap an option üëáüèª.\", reply_markup=main_menu_keyboard())\n",
    "    st = chat_state.get(chat_id, {})\n",
    "    if st.get(\"mode\") != \"invest\":\n",
    "        chat_state[chat_id] = {\"stage\":\"await_query\"}\n",
    "\n",
    "# ---------------- MAIN ----------------\n",
    "if __name__ == \"__main__\":\n",
    "    print(\"Bot starting...\")\n",
    "    bot.infinity_polling(timeout=60, long_polling_timeout=60)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8eae4c8e-d371-4fbf-b705-16e890168372",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "83db4094-0666-4a76-9738-acb0b0a04e6d",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3e9fcdba-717a-443f-bc5c-a5769a4e9af3",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
